**Don't forget to locally host files**
python -m SimpleHTTPServer

**Solution from the internet**
You first create or match the :A node, then create or match the :B node, then create or match the relationship. The WITH clauses collect the results at each point in the sequence to use in the next.

***IMPORT PRESIDENTS***
USING PERIODIC COMMIT
LOAD CSV WITH HEADERS FROM "http://localhost:8000/presidents.csv" AS csvLine FIELDTERMINATOR '|'
MERGE (n:Page {id: csvLine.source})
WITH csvLine, n
MERGE (m:Page {id: csvLine.target})
WITH m, n
CREATE (n)-[:LINKS_TO]->(m)

**SHORTEST UNDIRECTED PATH**
MATCH (m {node:"1"}), (n {node:"200"}), p = shortestPath((m)-[*]-(n)) RETURN p

**ALL SHORTEST UNDIRECTED PATHS**
MATCH (m {node:"1"}), (n {node:"200"}), p = allShortestPaths((m)-[*]-(n)) RETURN p

**How to calculate centrality**
As your graph is mainly static you can also run a simple cypher script to store the degree centrality on each node.

start n=node(*)
match n--()
with n,count(*) as centrality
set n.centrality = centrality

Then you can use that property, you can also use the first 3 lines of the snippet in your actual query for the nodes you're looking at.